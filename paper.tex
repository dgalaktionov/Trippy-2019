% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{enumerate}
\usepackage{marginnote}
\usepackage[linesnumbered,commentsnumbered,boxed]{algorithm2e}
\usepackage{amsmath}
\usepackage{threeparttable}
\usepackage{multirow}
\usepackage[margin=0pt,skip=1pt]{subcaption}
\usepackage{xcolor}
\usepackage{fixltx2e}

\newcommand{\acumm}{T-Matrices} % T is for Total!
\newcommand{\acummname}{\mathsf{Trip-Matrices}}
\newcommand{\ctr}{XCTR}
\newcommand{\ctrname}{\mathsf{eXtended~Compact~Trip~Representation}}
\newcommand{\ttctr}{TTCTR}
\newcommand{\ctrq}{$\alpha$}
\newcommand{\ttctrq}{$\beta$}
\newcommand{\ttctrname}{\mathsf{Topology\&Trip-aware~Compact~Trip~Representation}}

\definecolor{red}{rgb}{1.0, 0.0, 0.0}

\newcommand{\ojo}[1]{{\color{red} OJO: \tiny #1}}

\begin{document}
%
\title{New Trippy Structure \thanks{Funded in part by European Union`s Horizon 2020 research and innovation programme
under the Marie Sklodowska-Curie grant agreement No 690941 (project
BIRDS). The Spanish group is also partially funded by Xunta de Galicia/FEDERUE
[CSI: ED431G/01; GRC: ED431C 2017/58; GEMA:IN852A
2018/14 and Innovapeme: IN848D-2017-2350417]; by MINECO-AEI/FEDER-UE
[Datos 4.0: TIN2016-78011-C4-1-R; and ETOMERDFD3:
TIN2015-69951-R]; and by FPI Program [BES-C-2017-0085]. M. A. Rodr´ıguez is
partially funded by Fondecyt-Conicyt grant number 1170497 and by the Millennium
Institute for Foundational Research on Data. }}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Nieves R. Brisaboa\inst{1} \and
Antonio Fari\~na\inst{1}\and
Daniil Galaktionov\inst{1,2} \and Tirso V. Rodeiro\inst{1} \and M. Andrea Rodr\'iguez\inst{3,4}}
%
\authorrunning{N. Brisaboa et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Universidade da Coru\~na, Laboratorio de Bases de Datos, A Coru\~na, Spain  \email{\{brisaboa, fari, d.galaktionov, tirso.varela.rodeiro\}@udc.es}  \and 
Enxenio S.L., A Coru\~na, Spain
\and
Computer Science Department, Universidad de Concepci\'on, Concepci\'on, Chile \and Millennium Institute for Foundational Research on Data, Santiago, Chile
\email{andrea@udec.cl }\\
 }
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The abstract should briefly summarize the contents of the paper in
15--250 words.

\keywords{Compact structures  \and Compression \and Trajectories}
\end{abstract}
%
%
%
\section{Introduction}
With the increasing use of passenger tracking technology on public transportation networks, it is becoming necessary to store a constantly growing amount of information regarding the usage (demand) of the networks, which is different from the well-known information of stops and timetables (offer). To enable analysis over these large collections of data, a compact yet indexed representation is needed that, unlike the works that focus on indexing moving objects, allows for representation and querying of relevant network elements related to passenger trips.

A practical representation for this information in a data structure that supports efficient indexed search would have numerous possible applications, specially for transportation companies interested in studying the ridership \cite{tu2018spatial} and, therefore, improve the efficiency of the network, such as in \cite{weng2018mining}. Another application that is enabled by such analysis is the targeted advertising \cite{zhang2017targeted}, as being able to predict travel patterns for different user profiles could be extremely useful for an advertiser.

%These guys \cite{wang2014aggregated} made it so boring that they are probably not worth citing, but I'm keeping them here for now because they separate fridays and types of days, even though we don't care much about that anymore. OR DO WE?

In this work we introduce our approach on a flexible and efficient representation for analyzing the demand of real transportation networks using compact data structures. We have observed that there are two different kinds of queries that can be considered as useful to study the movement patterns of public transport users, for which we developed two complementary representations: \acumm~and \ttctr, with a second version for the later called \ctr, that addresses some of the limitations of \ttctr~to efficiently support more types of queries.

\subsubsection{Outline}
This work is structured as follows. We start with a detailed review of related works in Section~\ref{sec:rw}, where we discuss the state of the art for trajectory indexing, mining and then we present the underlying structures that our representation is based on. It is followed by Section~\ref{sec:model}, where we explain our design for a data model that can support relevant queries over transportation networks. In Section~\ref{sec:ps} we detail the composition of our representations and analyze their time efficiency for the targeted queries, followed by a practical analysis in Section~\ref{sec:exp}, where we evaluate the performance on a real transportation network. Finally, the conclusions can be found in Section~\ref{sec:conc}.


\section{Related works}
\label{sec:rw}
\subsection{Trajectory indexing}
Literature on spatial trajectory indexing can be categorized by the nature of the trajectories: they can be either constrained to a network or in free space. While there are well-known queries for indexes that work on moving objects in free space \cite{DBLP:conf/vldb/PfoserJT00}, the network constrained trajectory indexes cover more diverse querying needs, as different networks involve different kinds of challenges (as in vehicular road network vs public transportation network), and also because the intended application may vary (analyzing trip-chaining patterns vs number of passengers within a time window). A comprehensive review on indexing methods can be found in \cite[Chapter 4]{DBLP:books/sp/PelekisT14}.
%, to which we shall expand in the rest of this section to mention the most notable indexes and some new developments \ojo{Desde la referencia NO}.

\subsubsection{Free trajectory indexing}
Several adaptations of the {\em R-Tree} \cite{DBLP:conf/sigmod/Guttman84} are widely used for the indexing of moving objects. The most common approach is to integrate the temporal dimension in the R-Tree itself, as found in the {\em STR-Tree} and the {\em TB-Tree} from \cite{DBLP:conf/vldb/PfoserJT00}.
Another common approach is to complement the R-Tree with another similar structure for time indexing, as has been done for the {\em MV3R-tree}~\cite{DBLP:conf/vldb/PapadiasT01},
where an Historical {\em R-Tree}~\cite{nascimento1998towards} to partition on the temporal dimension.

The observation that, even for free trajectories, temporal dimension is generally more selective than spatial dimensions was heavily exploited in the subsequent works, such as {\em SETI} from \cite{chakka2003indexing}, where the space is partitioned statically and the time is indexed with a one dimensional R-Tree.

Recently a framework based on Apache Spark called {\em UlTraMan}~ \cite{ding2018ultraman} was developed. It supports different kinds of partitioning schemes for large collections of trajectories to answer range, kNN or aggregation queries \ojo{Queries NO definidas aun}, allowing to dynamically change the partitioning of the dataset in order to maximize the query time efficiency for a given query type. Although UlTraMan has been tested over network constrained trajectories, it does not appear to be exploiting network information in any way, hence its inclusion in this category.

In the field of compact data structures, an index called {\em GraCT}~\cite{brisaboa2019gract} has been developed, based on snapshots at regular time intervals representing the real position of the object at that time using {\em k$^2$-Trees}~\cite{brisaboa2009k} and movement logs for individual trajectories to which grammar compression (using {\em RePair}~\cite{larsson2000off}) is applied. Because of this, GraCT is a self-indexed compact representation that supports spatio-temporal range and nearest-neighbor queries, as well as allowing for direct access to the trajectory information of objects moving in open space (planes, ships\dots).

\subsubsection{Network constrained trajectory indexing}
There are also numerous approaches that use R-Tree based indexes for trajectories that are constrained to an underlying network, aiming to decrease the redundancy in the representation by separating the representation into levels: the network elements (usually roads or road segments), and the trajectories over this network which, unlike the network elements, is expected to grow asymptotically over time. Examples of such indexes include the {\em FNR-Tree}~\cite{DBLP:conf/ssd/Frentzos03}, where the network elements are indexed with a 2D R-Tree and 1D R-Trees to index time intervals of the objects' movements along the edges of the network. Some of the limitations of the FNR-Tree are addressed in \cite{DBLP:journals/geoinformatica/AlmeidaG05}, where the authors propose the {\em MON-Tree}, where the moving objects are indexes in two dimensional R-Trees (the dimensions being edge position vs time). More recent alternatives, such as the {\em TMN-Tree}~\cite{chang2010tmn}, integrate {\em B$^+$-Trees}, which have proven to be more space and time efficient for indexing the temporal dimension. Alternatively, in \cite{rivera2018faster} a compact representation of time intervals is proposed using two bitvectors, that can be combined with these R-Tree based indexes to increase the efficiency for temporal filtering. Refer to \cite{john2017performance} for a quick comparison of these R-Tree based indexes.

As a competitive alternative to these R-Tree based indexes, {\em PARINET}~\cite{DBLP:journals/vldb/PopaZOBV11}, builds spatial partitions from the trajectories based on their distribution and network topology, and uses a B$^+$-Tree to index the trajectories in each partition by time intervals. Although candidate trajectories must be filtered in memory during queries, PARINET is highly efficient in practice as its partitioning strategy minimizes the number of disk accesses needed.
%The same ideas were used in {\em TRIFL}~\cite{that2015trifl}, where the cost model is adapted for flash storage.

Another relevant representation is described in \cite{DBLP:conf/gis/KroghPTT14}. Their proposed index, {\em NETTRA}, was designed to efficiently solve a specific kind of query called {\em Strict Path Queries (SPQ)} that finds all the trajectories that follow the queried path from the beginning to its end. Built on a traditional RDBMS with $B^+$-Tree indexes. Another distinctive feature of NETTRA is its treatment of network constrained trajectories as textual information, which allows to apply string matching techniques such as fingerprinting functions to determine what trajectories have similar paths on their traversed edges. This close equivalence between trajectories and strings has been further exploited by Geodabs~\cite{chapuis2018geodabs}, where both the spatial distribution and sequence information are taken into account for finding trajectories by similarity with fingerprinting. These text-based approaches are sometimes tangled with works on the topic of semantic trajectories such as \cite{al2017semantictraj}.

%For vehicles we also have this \cite{cai2018vector} and \cite{lovell2018lossless}.

A recent compact data structure named {\em CiNCT} has been proposed in \cite{koide2018cinct}, where trajectories are encoded into a string, that is used to build an FM-index \cite{DBLP:conf/focs/FerraginaM00} with a Huffman-shaped Wavelet Tree \cite{ferragina2009compressed}. Due to space optimization, the string is constructed with relative movement labels instead of absolute edges, with an auxiliary structure that represents a network graph built from the input trajectories themselves. While this structure excels at pattern-matching and path extraction in street networks, it is not the most adequate for studying traveling patterns over public transportation networks that are based on routes, stops or similar abstractions.

\subsection{Trajectories retrieval}
Currently there are several known techniques that would allow to collect data regarding users' trips over a public transportation network. Numerous works exist where those trajectories are mined from the transactions of smart cards \cite{bhaskar2015passenger,wang2014aggregated}. This can be complemented with information derived from GPS devices, as shown in \cite{ma2014development}. Alternatively, reliable trajectories may be extracted relying on positioning obtained from cellular networks, as proven by \cite{liu2017exploring}.

Because smart card methods usually provide only information about boarding stops, there are works that study the challenge of inferring alighting stops from passengers \cite{wang2011review}. In addition, the authors of \cite{tao2014exploring} have specifically tackled the challenge of reconstructing full trajectories, accounting for trip-chaining, by using data obtained from smart cards. Furthermore, in \cite{alsger2016validating} it is also proven that not only the alighting stops, but also the (last) destination stop of a trip can be estimated from boarding data gathered by a smart card, within a reasonable accuracy.

This summarized review proves that \ojo{¿La nuestra?}, although we were not able to access real data from a public transportation company for this work, such curated information about users' trips can indeed be obtained and used for our proposed representations.

\subsection{Underlying structures and algorithms}
\subsubsection{Summed Area Tables}
The Summed Area Tables were first introduced in computer graphics \cite{crow1984summed} to speed up the mipmapping process. In this work we use this approach in order to manage aggregated data about user trajectories based on the idea that an amount of passengers share the same ride (with all its implications: times, trajectories...).

\subsubsection{Bitvectors}
\label{sec:bit}
A great amount of works in Compressed Data Structures have proposed solutions based on bitvectors, both compressed and uncompressed. For a bitvector $B[1,n]$ the following operations are expected to be supported:

\begin{itemize}
    \item $rank_1(B,i)$ returns the number of set bits in $B[1..i]$. Alternatively, $rank_0(B,i) = i - rank_1(B,i)$ and also $B[i] = rank_1(B,i-1) - rank_1(B,i)$.
    \item $select_1(B,i)$ returns the position in $1..n$ where the $i$th 1 occurs. Therefore, $rank_1(B,select_1(B,i)) = i$.
\end{itemize}

These operations can be supported in constant time with $o(n)$ extra bits \cite{Jac89,Mun96}, although several techniques exist for compressing bitvectors \cite{Raman:2002:SID:545381.545411,okanohara2007practical,Golynski2007}.

\subsubsection{Compressed Suffix Array (CSA)}
\label{sec:csa}
One common structure to count or locate all the occurrences of a pattern $P[1,m]$ in a string $S[1,n]$ of symbols from an alphabet $\Sigma$ is the Suffix Array (SA) \cite{MM93}. The SA is an array $A[1,n]$ with the positions $i$ of all suffixes $\{S[i..n] : 1 \leq i \leq n\}$, lexicographically sorted holding that $S[A[i]..n] \prec S[A[i+1]..n]$. This allows to find out all the occurrences of a substring $P[1,m]$ in $O(m \log n)$ time with binary searches.

A simple enhancement to avoid storing the original string $S$ is to align $A$ with a bitvector $D[1,n]$ where $D[i]=1~\Leftrightarrow~S[A[i-1]] \prec S[A[i]]$. That is, $D$ marks with a 1 all the positions in $A$ where the starting symbol of that suffix $S[A[i]]$ has a larger lexicographical value than the one from the previous positions $S[A[i-1]]$. With $D$, keeping $S$ is not longer needed as $S[A[i]] = rank_1(D,i)$.
%, where $rank_1(D,i)$ returns the number of set bits in $D[1..i]$.

Sadakane's CSA \cite{Sad03} further reduces the space by replacing $A$ with a permutation $\Psi[1,n]$ \cite{GV00}, where given $A[i]=k$ and $A[j]=k+1$, $\Psi[i]=j$, while keeping the capability to count the occurrences of $P[1,m]$ in $O(m \log n)$ as the bitvector $D$ is still valid for the entries of $\Psi$. Although an uncompressed $\Psi$ would have the same space requirement as $A$, it is much more compressible as it is formed by $\sigma$ strictly increasing subsequences, being $\sigma$ the size of the alphabet $\Sigma$. Furthermore, it has been proved in \cite{NM07} that $\Psi$ can be split in $nH_k+\sigma^k$ (for any $k$) runs of consecutive values. It is therefore possible to compress $\Psi$ using $\delta$-encoding and run-length for the (frequent) runs of consecutive values. This property has allowed \cite{FBNCPR12}, among others, to achieve compression rates comparable to gzip for English text, while maintaining relatively fast random access by storing samples at regular intervals.

\subsubsection{Wavelet Matrix (WM)}
\label{sec:wm}
Based on the Wavelet Trees \cite{WT03}, the Wavelet Matrix \cite{CNO15} is a structure that is able to perform, given a sequence $S[1..n]$ over the vocabulary $\Sigma$, operations of $rank_a(S,i)$ and $select_a(S,i)$ $\forall a \in \Sigma$ in $O(log\sigma)$ time while using $n\lceil log_2\sigma\rceil~+~o(n)$ bits of space, begin $\sigma = |\Sigma|$.

The WM is built with $\lceil log_2\sigma\rceil$ levels, each level having a bitvector $B_i$ with rank and select capabilities, where $B_1$ contains the most significant bit of every symbol $a \in S$, $B_2$ contains the second most significant bit and so forth. To further explain how these bits are positioned, we must consider $a_i$ as the $i$th bit of $a$ in significance, and $B^{-1}_i[a_i]$ as the position of the bit $a_i$ from $a$ in the bitvector $B_i$. Then, 
\[
    B_i[j] = \left\{\begin{array}{lr}
        S[j]_1, & \text{iff } i=1\\
        a_i, & \text{iff } i>1 \wedge (a_{i-1}=0 \wedge j=rank_0(B_{i-1},B^{-1}_{i-1}(a_{i-1}))) \\
        & \vee~(a_{i-1}=1~\wedge~j=rank_0(B_{i-1},n)~+~rank_1(B_{i-1},B^{-1}_{i-1}(a_{i-1})))
        \end{array}\right.
\]

That is, $B_1$ contains all the bits $a_1 \forall a \in S$, in the same order as in S. After that, $B_2$ contains the $a_2$ bits from those $a$ such as $a_1 = 0$ first, followed by those with $a_1 = 1$. That way, all the position of each $a_i$ in $B_i$ depends first by the value of $a_{i-1}$ and later by their position in $B_{i-1}$. Refer to the structures \texttt{WML} and \texttt{WMJ} in Figure~\ref{fig:example_xctr} for examples of one and two-leveled WM. Additionally, there exists a conceptual \textit{leaf level}, that is formed by the final position of every $a$ after applying the recursion on the last level. Because the sorting of each level depends on the values of the previous most significant bits, in the leaf level all symbols are sorted by their reverse representation in bits.

This structure allows to answer the following operations in $O(\log\sigma)$ time:
\begin{itemize}
    \item $access(S,i)$ returns the value in any position in the original sequence $S$ by following through the levels of the WM using the $rank$ operation on bitvectors. If $B_1[i]$ is 0, then $B_2[rank_0(B_1,i)]$ must be accessed next. Otherwise, it is $B_2[rank_0(B_1,n) + rank_1(B_1,i)]$. This must be recursively applied until the leaf level is reached, and the traversed bits will compose the value of $S[i]$.
    \item $rank_a(S,i)$ is calculated with the same operations as in $access$, with the difference that in this case we know whether we need to use $rank_0$ or $rank_1$ on each bitvector as the value of the symbol $a$ is known. To calculate the number of occurrences of $a$ in $S[1..i]$ we must simply subtract the position reached in the leaf level to the position of the first occurrence of $a$ on that level, which can be either stored for each symbol in $O(\sigma\log n)$ bits or calculated by making an analogous traversal from the first position of $S$.
    \item $select_a(S,i)$ first $i$ must be added to the first position of $a$ in the leaf level, which as for $rank$, can be either stored or calculated. After obtaining this position $j$, the WM must be traversed in reverse order using $select$ on bitvectors until the first level is reached. When $a_i=0$ the traversal from the lower level position $B_{i+1}[j]$ must be as $select_0(B_i,j)$, while when $a_i=1$, it is done as $select_1(B_i,j-rank_0(B_{i},n))$.
    \item $range_{a,b}(S,i,j)$ returns the number of occurrences of the symbols between $a$ and $b$ in $S[i..j]$. This operation was first introduced in \cite{gagie2012new} for Wavelet Trees and later supported by the Wavelet Matrix \cite{CNO15}, and we make extensive use of it in this work. It is solved with two simultaneous traversals similar to $rank$ over $i$ and $j$, only that it is possible that at some levels it is required to calculate both $rank_0$ and $rank_1$. However, the worst case time complexity of $O(\log\sigma)$ is maintained, due to the fact that it is not necessary to reach the leaf level for all the symbols in $a..b$\footnote{As long as $a\neq b$. Otherwise, $rank_a(S,j)-rank_a(S,i)$ can be used.}.
\end{itemize}

While a compression method is proposed in \cite{CNO15} by using canonical Huffman encoding on the symbols, it could not be applied in our work because it severely reduces the efficiency of $range_{a,b}(S,i,j)$. Instead, we focused on compressing the bitvectors and using ad-hoc optimizations to reduce the average height of our WMs.

\section{Our model for compact trip representation}
\label{sec:model}
In our previous representation introduced in \cite{brisaboa2018new}, we propose a model to represent the demand information for a public transportation network, as seen in the Figure~\ref{fig:er}.

\begin{figure}
%\centering
\includegraphics[width=\textwidth]{NetworkER.pdf}
\caption{An (updated) ER diagram representing the work-in-progress model for user trips in public transportation}
\label{fig:er}
\end{figure}

These are the main elements from our model:
\begin{itemize}
    \item A \textbf{stop\_place} is a physical stop with a location, on which several lines may make stops.
    \item A \textbf{line} is an ordered sequence of stop places that can be traveled by a transport vehicle, such as a bus or a train. It only considers one direction. For this reason, there is often a different and complementary line for the opposite direction, as shown in the Figure~\ref{fig:example_network}.
    \item A \textbf{journey} is a singular traversal of a transport vehicle over a line. It can be seen as a vehicle trip, instead of a user trip.
    \item A \textbf{stage} is formed by a boarding from a stop and alighting to another from the same single line and journey.
    \item An \textbf{user\_trip} is a concatenation of several stages, until the final destination (alighting stop of the last stage) is reached.
\end{itemize}

\begin{figure}
\includegraphics[width=\textwidth]{example_network.eps}
\caption{An example network for our model, with two lines and six stops}
\label{fig:example_network}
\end{figure}

This approach allows us to treat the information in a layered fashion: the bottom layer is a static network representation, formed by the line and stop\_place types, the middle layer represents the journeys made by vehicles that make stops at specific times, while the top layer are the trips made by the users over these vehicle journeys. In the Figure~\ref{fig:example_network} we show an example for the two bottom layers, where Line 1R is the reversed of Line 1. Our proposed implementation can be found in Section~\ref{sec:ps}.

Finally, it is possible to introduce a \textbf{user} identity, with an anonymized identifier to split trips by users. However, we do not consider such information useful for the kind of analysis that this work focuses on. If needed in the future, this additional entity could be trivially integrated in our representation.

\subsection{Relevant queries}
\label{sec:rq}
In the context of public transportation networks, we are interested in solving two kinds of queries, which we will present with a non-comprehensive list of examples that can be solved with the structures proposed in this work:

\begin{enumerate}[A)]
    \item Queries about the network load, asking for the gross number of users that boarded or alighted within a stop and a time/journey. Furthermore, it can be also interesting to obtain the average load of a bus or a train between any two stops from its line. Some of those queries are:
    \begin{itemize}
        \item \texttt{board\_X$_{LT}$} Number of users that stop X is boarded, optionally restricting to a line L and a time range T.
        \item \texttt{alight\_X$_{LT}$} Number of users that stop X is alighted, optionally restricting to a line L and a time range T.
        \item \texttt{use\_L$_T$}  Number of users (boardings) for the line L, optionally restricting to a time range T.
        \item \texttt{board\_T} Number of users boarding within a time range T.
        \item \texttt{alight\_T} Number of users alighting within a time range T.
        \item \texttt{load\_X$_{LT}$} The average number of passengers traveling from the stop X to its next stop in the line L within the time range T. Can also be seen as the average load of the vehicle.
    \end{itemize}
    \item Queries about user trips patterns. With his kind of queries we can obtain the number of times a stop was used to switch lines or the number of trips that started on a stop with another specific stop as the final destination. In this work we consider the following queries of this kind:
    \begin{itemize}
        \item \texttt{start\_X$_{LT}$} User trips starting at a stop X, optionally restricting to a line L and a time range T.
        \item \texttt{end\_X$_{LT}$} User trips ending at a stop X, optionally restricting to a line L and a time range T.
        \item \texttt{switch\_X$_{L\textsubscript{1}L\textsubscript{2}T}$} Number of trips in which the stop X was used to switch lines, optionally restricting to a line L\textsubscript{2} and a time range T.
        \item \texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} User trips that originate at stop X to end at stop Y, both being optionally restricted to a line and time range.
        \item \texttt{start\_L$_T$} User trips starting at any stop from the line L, optionally restricting to a time range T.
        \item \texttt{end\_L$_T$} User trips ending at any stop from the line L, optionally restricting to a time range T. \ojo{revisar}
        \item \texttt{start\_T} User trips starting within a time range T.
        \item \texttt{end\_T} User trips ending within a time range T.
    \end{itemize}
\end{enumerate}

\section{Proposed Structures}
\label{sec:ps}
To the best of our knowledge, there is no indexing structure that would allow to efficiently represent trajectories that could also support all the kinds of queries described in Section~\ref{sec:rq}. For this reason, we propose a solution that relies on two data structures, \acummname~(\acumm)~and~\ttctrname~(\ttctr). The former is targeted for queries of type A, solving most aggregation queries in constant time, while the later can be used for queries of type B. Finally, we introduce a more versatile alternative to \ttctr~that we call \ctrname~(\ctr).

\subsection{Common Data Structures}
\label{sec:cs}
Our developed solution needs a network representation to be operated, along with information about the transport vehicle journeys. Therefore, the following structures represent a network with stops $s_i \in S = \{1,...|S|\}$, lines $l_i \in L = \{1,...|L|\}$ and journeys $j_i \in J^l = \{1,...|J^l|\}$. It is important to state that journeys are \textbf{not} identified by $j_i$, as the same $j_i$ can belong to several $J^l$ from different lines, so we speak about journey \textbf{codes} (jcodes) instead of journey identifiers.

\begin{itemize}
    \item $lineStop_i(j)$ is the $j$th stop of line $l_i$
    \item $stopLine_i(j)$ is the $j$th line that makes a stop at the stop $s_i$
    \item $avgTime_i(j)$ is the average time in seconds that it takes for a vehicle of line $l_i$ to reach its $j$th stop from the start of a journey
    \item $initialTime_i(k)$ is the starting time of the journey $j_k$ for line $l_i$
\end{itemize}

With the exception of $initialTime$, all these structures are small enough to be represented using plain fixed-length integer arrays. In the case of $initialTime$, its size naturally grows with the amount of trips that are indexed, thus there is a motivation to reduce its size, which can be easily achieved with any technique that works on posting lists or sequences of strictly increasing numbers. In our work we used a simplified Vbyte+ANS compression described in \cite{moffat2017ans} using the Zstd library\footnote{https://github.com/facebook/zstd}. In order to facilitate searches and random access, we introduced fixed-length samples on configurable intervals.

An example of these structures interacting together can be found at the Algorithm~\ref{alg:jcodes}, the the function \FuncSty{lower\_bound} is a binary search that returns the index of the first occurrence that is no lesser than the queried value, while \FuncSty{upper\_bound} returns the index of the last no greater occurrence.

\begin{algorithm}[H]
\SetKwData{l}{$l$}\SetKwData{lz}{l$_z$}\SetKwData{s}{s}\SetKwData{sz}{s$_z$}\SetKwData{ta}{t$_a$}\SetKwData{tz}{t$_z$}\SetKwData{pattern}{pattern}\SetKwData{left}{left}\SetKwData{right}{right}\SetKwData{csa}{CSA}\SetKwData{wmj}{WMJ}\SetKwData{leftzero}{left$_0$}\SetKwData{rightzero}{right$_0$}\SetKwData{i}{i}\SetKwData{z}{z}\SetKwData{ja}{j$_a$}\SetKwData{jz}{j$_z$}\SetKwData{n}{n}\SetKwData{ap}{a'}\SetKwData{zp}{z'}\SetKwData{offset}{offset}
 \SetKwFunction{GetBounds}{GetBounds}\SetKwFunction{GetJCodes}{GetJCodes}\SetKwFunction{GetCount}{GetCount}\SetKwFunction{GetPsi}{$\Psi$}\SetKwFunction{GetRangeSpecial}{GetRange$^*$}\SetKwFunction{bsearch}{binary\_search}\SetKwFunction{lbound}{lower\_bound}\SetKwFunction{ubound}{upper\_bound}
 \SetKwProg{Fn}{Function}{\string:}{}
 
 \Fn{\GetJCodes{\l,\s,\ta,\tz}}{
 \KwData{line \l, stop \s, times \ta,\tz}
 \KwResult{jcodes for \ta and \tz}
 \BlankLine
 \offset $\leftarrow$ $avgTime_{\l}(\bsearch{$lineStop_\l$, \s})$\;
 \Return{\lbound{$initialTime_\l$, \ta-\offset}, \ubound{$initialTime_\l$, \tz-\offset}}\;
 }
 
 \caption{Obtaining the codes of the journeys from the line \l that should arrive to the stop \s within the time range given by \ta and \tz}
 \label{alg:jcodes}
\end{algorithm}

\subsection{\acumm}
\label{sec:acumm}
As it has been stated previously in this paper, nowadays it could be relatively simple to gather massive information about user trips in every public transport; however, it is not necessary to store individually each trip. If there are two (or more) travelers sharing the same bus (train/tram/etc), they are also sharing the route, the stops (the time of each stop) and even the network. Therefore, a structure storing the aggregated data of the user trips would be a handy solution to solve (at least) queries of type A presented in section 3.

\begin{figure}[h!]
  \includegraphics[scale=0.65]{Tmatrices.png}
  \caption{T-Matrices example}
  \label{fig:tmatrix}
\end{figure}

Thus, we propose the T-Matrix, an accumulated solution that involves two-dimensional matrices of integers enabling aggregated queries by row, column, or window/range. In the context of a public transportation network, it would be useful to solve flexible line-centered queries; that is, queries that support aggregation by any dimension. Therefore, it could be possible to aggregate either by time-interval (e.g. number of users got on at any stop of the line on 2019/01/02); by stop (e.g. number of passengers that got on a bus at stop S); or by stop and time-interval.

In a na\"{\i}ve representation, it would only be necessary a two-dimensional matrix having stops as rows and journeys as columns, so each cell would have an integer representing the number of passengers that got on the vehicle at a specific stop in a particular time (journey). The main issue with this approach is that for each query it would be necessary to sum integer by integer each cell of the solution; hence, if we are trying to compute how many people got on a bus in several consecutive stops during a time interval (several consecutive journeys) it would be necessary to sum all the cells within the submatrix that match these journeys and stops.

On the other hand, T-Matrix is based on this na\"{\i}ve proposal but instead of storing each cell as a simple integer it assigns an accumulated value to each slot, being the top left cell the smaller number and the bottom right position the cumulative value resulting from adding all the previous cells. Despite having larger numbers in almost every slot of the matrix, this approach allows to apply the dynamic programming formula that follows:

$\mathsf{countRange((x_1,y_1),(x_2,y_2))} \leftarrow {M(x_2,y_2)} - {M(x_2,y_1-1)} - {M(x_1-1,y_2)} + {M(x_1-1,y_1-1)}$.

The combination of this operations with our proposed accumulative matrix enables to compute the same two-dimensional (or one-dimensional) queries in constant time O(1), as it is only necessary to access and sum four cells in all the matrix.

There are many options for compressing this cumulative matrix in order to get smaller dimensions, in this work we considered two relatively simple options with competitive results. One simple way of dealing with the growth of numbers in our cumulative solution is just apply a kind of sampling with differences; in this way, a basic example could be keep the middle column (\textit{$\mathsf{middle $\leftarrow$  (  \mathopen|c\mathclose|   + 1)/2} $}) explicitly, and representing the values in the other columns \textit{m±k} as the difference with respect to column \textit{m} (Diff in figure \ref{fig:tmatrix}). Being the algorithm to revert this differences as the one shown in Algorithm  \ref{alg:undiff}.



\begin{algorithm}[hbt!]

\SetKwData{value}{value}
 \SetKwFunction{extract}{Undiff}
 \SetKwProg{Fn}{Function}{\string:}{}
 
 \Fn{\extract{x, y}}{
 \KwData{coordinates x , y} 
 \KwResult{Value in the original cumulative matrix}
 \BlankLine
 \value $\leftarrow$ 0\;
 \BlankLine
 
\eIf{$ y == middle $}
            {$ \value = diffMatrix[x][y]$}
            {\eIf{$ y < middle $}
                {$ \value = diffMatrix[x][middle] - diffMatrix[x][y]$}
                {$ \value = diffMatrix[x][y] - diffMatrix[x][middle]$}}
 

 \BlankLine
 \Return{\value}\;
 }
 
 \caption{Obtaining the real value of any coordinates in the original cumulative matrix through the difference matrix}
 \label{alg:undiff}
\end{algorithm}


Taking this simple algorithm one step further we have built a cumulative matrix with several sampling rows, reducing significantly the size of the structure. Hence, this new differential matrix (Blocks in figure \ref{fig:tmatrix}) is divided in square blocks where the first line in each block remains the same as in the cumulative matrix while the rest of the rows in the block are calculated from it. A more technical description would be as follows in the simplified algorithm \ref{alg:unblock}.


\begin{algorithm}[hbt!]

\SetKwData{value}{value}
 \SetKwFunction{extract}{Unblock}
 \SetKwProg{Fn}{Function}{\string:}{}
 
 \Fn{\extract{x, y, block\_size}}{
 \KwData{coordinates x , y; 
         block_size: dimension of the each block} 
 \KwResult{Value in the original cumulative matrix}
 \BlankLine
 \value $\leftarrow$ 0\;
 \BlankLine
 
\eIf{$ x  \mod  block\_size $}
            {$ \value = blockMatrix[x][y]$}
            {$ \value = blockMatrix[x][y] + blockMatrix[x - (x  \mod  block\_size)][y]$}
 

 \BlankLine
 \Return{\value}\;
 }
 
 \caption{Obtaining the real value of any coordinates in the original cumulative matrix throught the difference matrix}
 \label{alg:unblock}
\end{algorithm}



\subsection{\ttctr}
\label{sec:ttctr}
A user trip can be represented by the stops from the transportation system that were boarded by a user, so from now on we will consider a trip as a sequence of triplets $<s,l,j>$, where $s$, $l$ are, respectively, stop and line identifiers, while $j$ are the journey codes corresponding to the journeys that compose the trip. These triplets describe a trip in a consecutive fashion, on the same order as the stops were boarded. Additionally, as we are interested in knowing where the trips end, we also represent the last stop where the user has alighted, which line and journey will logically match the line and journey of the last boarding stop. Although it is generally hard to obtain information about the last destination stop of a trip, many transportation companies are investing effort in providing it, either by implementing systems to keep track of users as they leave their system or estimating it based on previous trips made by that user \cite{alsger2016validating}.

\ttctr~was introduced in \cite{brisaboa2018new}, where the spatial component (the pairs $(s,l)$ for the stops and lines of a trip) is represented with a \texttt{CSA} where each unique pair $(s,l)$ is encoded as an integer $id$ in the input sequence $T[1,n]$ that is used to build the \texttt{CSA}.

In this work, \ttctr~is built first by sorting all trips. If we consider that a trip is composed by $n$ of the $<s_i,l_i,j_i>,~1\leq i\leq n$ triplets previously described, where the first triplet corresponds to the first boarded stop and the last triplet corresponds to the last alighted stop (final destination), then the collection of trips is sorted by the key $s_1,s_n,l_1,j_1$. That is, trips are initially sorted by the first boarded stop identifier. If these are equal, they are then sorted by their last stop identifier, analogously followed by the line identifier and journey code of the first stop. Figure~\ref{fig:example_trips} displays an example of a correct sorting of trips.

\begin{figure}[hbt!]
\includegraphics[width=0.4\textwidth]{example_trips.eps}
\caption{An example five trips sorted as required by \ttctr~and \ctr}
\label{fig:example_trips}
\end{figure}

We also need an injective function to encode the pairs $(s,l)$. Consider a vocabulary $V$ such that:
\begin{itemize}
	\item Entry $V[0]$ is reserved for the terminator symbol $\$$.
	\item Entries $\langle V[1],V[2], \dots V[|S|]\rangle]$ are associated to stops $s_1,s_2,\dots, s_{|S|}$ and are used to represent the final stops of the trips. That is, when a given stop $s_i$ ends a user trip, it is given $id \leftarrow s_i$.
	\item The following $|L|$$\times$$|S|$ entries are associated to the sequence composed of the pairs $(s,l) \in S\times L$, sorted first by the stop id $s$ and later by the line id $l$. That is, entry $V[|S|+1]$ is given to $(s_1,l_1)$; $V[|S|+2]$ to $(s_1,l_2)$; $V[|S|+3]$ to $(s_1,l_3)$; $\dots$; $V[|S|+|L|]$ to $(s_1,l_{|L|})$;  $V[|S|+|L|+1]$ to $(s_2, l_1)$, $V[|S|+|L|+2]$ to $(s_2, l_2)$, and so on. Therefore, it is easy to see that any $(s_i,l_j)$ is going to be associated to the entry $V[|S|+ |L|(i-1) + j]$.
\end{itemize}

While this arrangement would theoretically produce many entries in $V$ that are mapped to pairs $(s,l)$ that are unused in $T$, either because the stop is never traversed by that line or because we do not have the record of a user trip containing it, these entries can be skipped with a compact bitvector $B$ with rank and select capabilities, that marks with a one every used entry from $V$. This will enable us to operate with a much smaller vocabulary $V'$ with only the used entries from $V$, such that $V[i] = V'[rank_1(B,i)]$. Refer to the vocabulary shown Figure~\ref{fig:ttctr}(2) for an example where pairs $s:l$ are encoded to 43 unique identifiers in $V$. After that, $B$ marks which of the entries of $V$ actually appear in the original sequence. Finally $V'$ will contain only 12 entries, for each set bit from $B$. Note that neither $V$ nor $V'$ are explicitly represented in practice, as $rank$ and $select$ operations over $B$ are enough to map and unmap, respectively, vocabulary identifiers.

\begin{figure}
\includegraphics[width=\textwidth]{network.eps}
\caption{Network representation for the example of \ttctr~from Figure~\ref{fig:ttctr}}
\label{fig:example_trips_ttctr}
\end{figure}

\begin{figure}
	%\vspace{-0.2cm}
    \includegraphics[width=1.00\textwidth]{ttctr2019.eps}
	%\vspace{-0.3cm}
	\caption{Structures involved in the creation of a \ttctr}
	\label{fig:ttctr}
	%\vspace{-0.2cm}
\end{figure}

After this, the sequence $T[1,n]$ is built, with the identifiers obtained from mapping mapping to the vocabulary entries of $V'$, over which a \texttt{CSA} is built, as seen in Figure~\ref{fig:ttctr}(3). Each encoded trip in $T$ is terminated with with additional $\$$ symbols. While in the final \texttt{CSA} we assign all these $\$$ a lexicographical value of 0 $(V[0])$, we assign them different values during the construction of the suffix array (A) to ensure that the entries for $\$$ in $A$ maintain the same order as in the original text. Finally, we make a modification on $\Psi$ to make the entries of each $\$$ point to the start of its own trip instead of the next one. These two modifications are proven necessary for our implemented queries, at the expense of losing some of the properties of a classic CSA. For reference, in Figure~\ref{fig:ttctr} we also present $A'$ and $\Psi'$, that show how our modifications compare to the original CSA.

The journey codes ($jcodes$) are encoded in $Jcodes^{\Psi}[1,n]$, as shown in Figure~\ref{fig:ttctr}(4), that is aligned to $\Psi$ instead of $T$. $Jcodes[8]= 1$ corresponds to $Jcodes^{\Psi}[14]=1$, since $A[14]=8$; $Jcodes[9]= 2$ corresponds to $Jcodes^{\Psi}[18]=2$, since $A[18]=9$; and so on. Recall that $jcodes$ are relative to their line identifiers, leading us to skip the $jcodes$ that would be aligned to the entries of $\Psi$ belonging to the final stops (represented as ``$s\!:\!*$" in $V$), as they lack line identifiers, which are in turn needed to identify a journey. Additionally, the first positions of $Jcodes^{\Psi}$, aligned with the $\$$ entries, we duplicate the same $jcodes$ as in the start of each trip.

%In parallel with the construction of $T$, we create a sequence $Jcodes[1,n]$ aligned to $T$ where we set, for each trip the $journey$-$id$ corresponding to each stage. Recall the $journey$-$id$ is the third term from the triples $(s_i,l_i,j_i),~i\in[1,k]$ from a trip. In addition, assuming that $s_p$ contains the $0$ corresponding to the terminator $\$$ for the trip, we set $Jcodes[p]\leftarrow j_1$ (i.e. the same journey-id as  the starting stop of the trip). According to the discussion above, Figure~\ref{fig:ttctr} shows:
%{\em (step-1)} the sequence of pairs $(stop,line)$ for each trip, and the corresponding $Jcodes$; {\em (step-2)} the vocabularies, including $V$, $B$, and $V'$ (ending stops $s$ of trips do not need the line, therefore we use ``$s\!:\!*$".);\footnote{In this example, with only $5$ trips,  we have only $11$ {\em used pairs} in $V$, but in a real scenario for each stop of each line ({\em existing pair} $(s,l)$) 
%	there will be a $1$ in $B$.} 
%and {\em (step-3)} the structures involved in the creation of \texttt{CSA} from which \ttctr~uses $\Psi$, $D$, (and $V'$, $B$).

%The temporal component of \ttctr includes the sequence $Jcodes$ described above. Recall $Jcodes$ contains $journey$-$ids$ aligned to the values in $T$, and that, for every line $l$ there are $n_j^l$ journeys sorted by their starting time and numbered as $0\dots n_j^l-1$, and also we have average accumulated times to reach each stop in the line. Therefore, this representation allows us to describe exact times for each stop.

% In practice, we use $Jcodes^{\Psi}$, which is aligned to $\Psi$ rather than to $T$. See in Figure~\ref{fig:ttctr}(4).
% Note that $Jcodes[8]= 1$ corresponds to $Jcodes^{\Psi}[14]=1$, since $A[14]=8$; 
%           $Jcodes[9]= 2$ corresponds to $Jcodes^{\Psi}[18]=2$, since $A[18]=9$; and so on.

Finally, $Jcodes^{\Psi}$ is represented with a \texttt{WM}, to support the operations we need to evaluate our proposed queries while avoiding the overhead of other types of indices that are not based in compact representations.

With \ttctr~we obtain a clear separation between the spatial representation of the trips (\texttt{CSA}) and the temporal representation (\texttt{WM} of $jcodes$), where the former can be used to address queries such as ``number of passengers that started their trip from a stop $X\in S$ and a line $l\in L$'' (\texttt{start\_X$_{L}$} from Section~\ref{sec:rq}) with a binary search of the pattern $\$,X_l$, while the later can be used to filter down these results to a time window (\texttt{start\_X$_{LT}$}) with a $range_{a,b}(S,i,j)$ operation over the \texttt{WM}, where $a$ and $b$ are $jcodes$ obtained from Algorithm~\ref{alg:jcodes} and $i$ and $j$ delimit the range of the results obtained in $\Psi$. Because the $\$$ symbols were made cyclical in $\Psi$, it is also possible to answer \texttt{from\_X\_to\_Y} queries by searching for a pattern $Y,\$,X_l$ instead.

\subsection{\ctr}
\label{sec:ctr}
A fundamental weakness of \ttctr~is that it requires several binary search operations over the \texttt{CSA} in the following cases:
\begin{itemize}
    \item We are interested in the number of passengers that started their trip at a stop $s$ and a time window $t_a...t_z$, but from \textbf{any line} (\texttt{start\_X$_{T}$} from Section~\ref{sec:rq}). As $jcodes$ are relative to lines, we must make a separate query for each possible pair $(X, l_i) \forall l_i \in L$.
    \item We need to restrict the line of a final stop, in queries such as \texttt{end\_X$_{L}$} or \texttt{from\_X\_to\_Y$_{L}$} (and similar variations). Because the final stops belong to separate entries of the vocabulary that do not encode line identifiers, to restrict a stop $Y\in S$ to a line $l\in L$ we need to search for every possible expanded pattern $W_l,Y...$, for every stop $W$ from the line $l$ that could have been boarded before alighting at $Y$. While it looks tempting to address this issue by modifying the design of \ttctr~so that final stops also encode line identifiers, this would in turn make queries that do not restrict the line of the final stop inefficient, and we would need to perform a new query for every combination of $(Y, l_i) \forall l_i \in L$, as in the previous case. \marginpar{\tiny Viendo los experimentos, uno se puede preguntar si no habria quedado mejor meter lineas en paradas finales...}
\end{itemize}

These weaknesses motivated us to develop a second version, \ctr, which reduces the complexity of the queries that restrict the final line, and delegates line checks on a new WM, allowing a better space-time trade-off. As in \ttctr, the input trips need to be sorted by the same criteria, but in \ctr~we use three complementary structures to represent each component of the sequence, as shown in Figure~\ref{fig:example_xctr}:
\begin{enumerate}[(i)]
    \item An adapted Compressed Suffix Array (\texttt{CSA}) over the stop identifiers of all trips, concatenated into a string with additional terminator symbols $\$$ appended at the end of each trip. As in the \texttt{CSA} from \ttctr, we make these $\$$ symbols maintain the order of the trips and cyclical in $\Psi$. Because this time we do not encode line and stop identifiers together and \texttt{CSA} only encodes stops, there is no need for a complex vocabulary anymore.
    \item \texttt{WML}: Aligned to the entries of (i) there is a Wavelet Matrix (WM) for the line identifiers of each stop. Aligned to the $\$$ section we duplicate the starting lines of each trip. As a trivial optimization, we build a separate WM for every stop, allowing us to save space due to the fact that a single stop does not usually belong to many lines, thus the average height of these WM is no larger (and usually smaller) than the height of a single WM.
    \item \texttt{WMJ}: A WM of jcodes aligned to the leaves of (ii). Note that this makes this structure dependant on (ii), which is coherent with the fact that journey codes themselves are relative to the line identifier. In case (ii) implements the optimization described, the entries of the WM must also be rearranged to match the delimited stops.
\end{enumerate}

\begin{figure}[hbt!]
\includegraphics[width=\textwidth]{example_xctr.eps}
\caption{An example of five trips represented on \ctr~with the optimizations for \texttt{WML} and \texttt{WMJ}, and sections for each stop delimited by dotted lines}
\label{fig:example_xctr}
\end{figure}

As \ctr~is a complete representation of the collection of trips, we are able to extract any trip using the structures described. \marginpar{The idea here is that explaining how to extract will help understand the more complex FromXtoY query later} The algorithm to extract a trip is shown in the Algorithm~\ref{alg:extract}, where \FuncSty{Rank} and \FuncSty{Select} operate over the bitvector $D$ from our \texttt{CSA}, \FuncSty{WML}{(s$_a$)} is the WM corresponding to the stop \DataSty{s$_a$} in the optimized version of \texttt{WML} and \FuncSty{TrackDown} returns the leaf index of a WM given a root index. In a practical implementation, it is not needed to access \texttt{WML} and \texttt{WMJ} for the line identifier and jcode of the last stop of the trip, as they will always match the previous ones.

\begin{algorithm}[hbt!]
\SetKwData{la}{$l_a$}\SetKwData{lz}{$l_z$}\SetKwData{sa}{s$_a$}\SetKwData{sz}{s$_z$}\SetKwData{ta}{t$_a$}\SetKwData{tz}{t$_z$}\SetKwData{pattern}{pattern}\SetKwData{left}{left}\SetKwData{right}{right}\SetKwData{csa}{CSA}\SetKwData{wmj}{WMJ}\SetKwData{leftzero}{left$_0$}\SetKwData{rightzero}{right$_0$}\SetKwData{a}{a}\SetKwData{z}{z}\SetKwData{ja}{j$_a$}\SetKwData{jz}{j$_z$}\SetKwData{n}{n}\SetKwData{ap}{a'}\SetKwData{zp}{z'}\SetKwData{offset}{offset}\SetKwData{i}{i}\SetKwData{trip}{trip}
 \SetKwFunction{GetRange}{GetRange}\SetKwFunction{GetJCodes}{GetJCodes}\SetKwFunction{GetCount}{GetCount}\SetKwFunction{GetPsi}{$\Psi$}\SetKwFunction{GetRangeSpecial}{GetRange$^*$}\SetKwFunction{wml}{WML}\SetKwFunction{TrackUp}{TrackUp}\SetKwFunction{Select}{Select}\SetKwFunction{fxy}{FromXtoY\_full}\SetKwFunction{extract}{Extract\_trip}\SetKwFunction{access}{Access}\SetKwFunction{rank}{Rank}\SetKwFunction{TrackDown}{TrackDown}
 \SetKwProg{Fn}{Function}{\string:}{}
 
 \Fn{\extract{\i}}{
 \KwData{trip number \i}
 \KwResult{Sequence of tuples $<s,l,j>$ that compose the trip}
 \BlankLine
 \trip $\leftarrow$ []\;
 \a  $\leftarrow$ \GetPsi{\csa, \i}\;
 \sa $\leftarrow$ \rank{\csa,\a}\;
 \BlankLine
 \While{\sa $\neq$ 0}{
    \z $\leftarrow$ \Select{\csa,\sa}\;
    \la $\leftarrow$ \access{\wml{\sa}, \a-\z}\;
    \ja $\leftarrow$ \access{\wmj, \TrackDown{\wml{\sa}, \a-\z}+\z}\;
    append $<\sa,\la,\ja>$ to \trip\;
    \a  $\leftarrow$ \GetPsi{\csa, \i}\;
    \sa $\leftarrow$ \rank{\csa,\a}\;
 }
 \BlankLine
 \Return{\trip}\;
 }
 
 \caption{Extracting the trip \DataSty{i} from \ctr, where \FuncSty{CSA}, \FuncSty{WML} and \FuncSty{WMJ} are the structures previously described in (i), (ii) and (iii), respectively}
 \label{alg:extract}
\end{algorithm}

An example of a complex query that we can solve with \ctr~is ``number of trips that started from a stop \DataSty{s$_a$} and ended at a stop \DataSty{s$_z$}'', which can be further restricted to specific starting and ending lines and a time window (\texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} in Section~\ref{sec:rq}). The pseudocode for the full version of such query can be found at the Algorithm~\ref{alg:xy}. This algorithm relies heavily on the abstract function \FuncSty{GetRange}, which when applied to a CSA, delimits the range of entries of $\Psi$ that match a queried string pattern, while on a WM it works as the $range$ operation defined in Section~\ref{sec:wm}, also reporting the range in the last level of a WM corresponding to the entries of a single queried symbol within a range in the encoded sequence (equivalent to two \FuncSty{TrackDown} operations on the first and last occurrence of the queried symbol, but more time efficient).

\begin{algorithm}[hbt!]
\SetKwData{la}{$l_a$}\SetKwData{lz}{$l_z$}\SetKwData{sa}{s$_a$}\SetKwData{sz}{s$_z$}\SetKwData{ta}{t$_a$}\SetKwData{tz}{t$_z$}\SetKwData{pattern}{pattern}\SetKwData{left}{left}\SetKwData{right}{right}\SetKwData{csa}{CSA}\SetKwData{wmj}{WMJ}\SetKwData{leftzero}{left$_0$}\SetKwData{rightzero}{right$_0$}\SetKwData{a}{a}\SetKwData{z}{z}\SetKwData{ja}{j$_a$}\SetKwData{jz}{j$_z$}\SetKwData{n}{n}\SetKwData{ap}{a'}\SetKwData{zp}{z'}\SetKwData{offset}{offset}
 \SetKwFunction{GetRange}{GetRange}\SetKwFunction{GetJCodes}{GetJCodes}\SetKwFunction{GetCount}{GetCount}\SetKwFunction{GetPsi}{$\Psi$}\SetKwFunction{GetRangeSpecial}{GetRange$^*$}\SetKwFunction{wml}{WML}\SetKwFunction{TrackUp}{TrackUp}\SetKwFunction{Select}{Select}\SetKwFunction{fxy}{FromXtoY\_full}
 \SetKwProg{Fn}{Function}{\string:}{}
 
 \Fn{\fxy{\la,\lz,\sa,\sz,\ta,\tz,\n}}{
 \KwData{lines \la,\lz, stops \sa,\sz, times \ta,\tz and length of the sequence \n}
 \KwResult{Number of occurences}
 \BlankLine
 \pattern $\leftarrow \{\sz,0,\sa\}$\;
 \left,\right $\leftarrow$ \GetRange{\csa, $0$, \n, \pattern}\;
 \leftzero $\leftarrow$ \GetPsi{\csa, \left}\;
 \rightzero $\leftarrow$ \GetPsi{\csa, \right}\;
 \tcp{\right-\left = \rightzero-\leftzero}
 \a,\z $\leftarrow$ \GetRange{\wml{$0$},\leftzero,\rightzero,\la}\;
 \ja,\jz $\leftarrow$ \GetJCodes{\la,\sa,\ta,\tz}\;
 \a,\z $\leftarrow$ \GetRangeSpecial{\wmj,\a,\z,\ja,\jz}\;
 \ap $\leftarrow$ \TrackUp{\wml{$0$},\a}\;
 \zp $\leftarrow$ \TrackUp{\wml{$0$},\z}\;
 \tcp{\z-\a = \zp-\ap}
 \offset $\leftarrow$ \Select{\csa,\sz}\;
 \a,\z $\leftarrow$ \GetRange{\wml{\sz},\left-\offset~$+$~\ap-\leftzero,
 \left-\offset~$+$~\zp-\leftzero,\lz}\;
 \ja,\jz $\leftarrow$ \GetJCodes{\lz,\sz,\ta,\tz}\;
 \Return{\GetCount{\wmj,\offset~+~\a,\offset~+~\z,\ja,\jz}}\;
 }
 
 \caption{Querying for all features on \ctr}
 \label{alg:xy}
\end{algorithm}

We will now proceed to explain the Algorithm~\ref{alg:xy} line by line:
\begin{itemize}
    \item In \textbf{lines 2-3}, we query our \FuncSty{CSA} for the pattern consisting of the destination stop \DataSty{s$_z$}, followed by a 0 (the code for the $\$$ symbol) and finally the origin stop \DataSty{s$_a$}. This results in a range of entries within the section of \DataSty{s$_z$} that belong to our queried trips, because the trips were made circular in $\Psi$, so each $\$$ points to the beginning of its own trip. If we were not interested in restricting lines nor time, the function would end here, returning \DataSty{right}-\DataSty{left}.
    
    \item In \textbf{lines 4-6} we obtain the corresponding range in the section of $\$$ by accessing \FuncSty{$\Psi$}. Note that because of how the sorting of the $\$$ symbols was altered during the construction of the suffix array, these two ranges are equal in size, as the comment in line 6 points out.
    
    \item In \textbf{line 7} we query \texttt{WML} in the $\$$ section, within the range previously obtained, for the queried starting line \DataSty{l$_a$}, obtaining the range of its occurrences in the last level, delimited by \DataSty{a} and \DataSty{z}. Note that if the \ctr~was constructed without the optimization that separates \texttt{WML} in sections, this line would be exactly the same, save for the query being on a \DataSty{WML} that would encode the whole sequence of lines instead of just the \DataSty{WML}{(0)} for $\$$.
    
    \item In \textbf{line 8} we obtain the range of jcodes for the journeys from the line \DataSty{l$_a$} that would pass through the stop \DataSty{s$_a$} within the time window delimited by \DataSty{t$_a$} and \DataSty{t$_z$}, using the function \FuncSty{GetJCodes} from Algorithm~\ref{alg:jcodes}.
    
    \item In \textbf{line 9} we operate over a range of \texttt{WMJ} that encodes a non-decreasing sequence of jcodes, given that within the same origin stop, final stop and starting line, the $\$$ were sorted by the starting journey code of their trips. This allows us to use a specially modified version of \FuncSty{GetRange} that is able to return the range of indexes on the first level of the WM instead of the last one. This is equivalent to finding the lower and upper bounds for the range \DataSty{j$_a$}$..$\DataSty{j$_z$} via binary searches in \FuncSty{WMJ} from \DataSty{a} to \DataSty{z}, but much more efficient.
    
    \item In \textbf{lines 10-12} we use the \FuncSty{TrackUp} operation, which is the inverse of \FuncSty{TrackDown}: it returns the root index given a leaf index of a WM. In this case, as the \FuncSty{a} and \FuncSty{z} we obtained in the previous step are also indexes in the last level of the \FuncSty{WML}, we use \FuncSty{TrackUp} to translate that range of indexes to the root of \texttt{WML} and therefore to the entries of the \texttt{CSA} as well. Note that this is a range inside the $\$$ section for trips with the same origin stop, final stop and starting line that includes all the trips for jcodes that span from \DataSty{j$_a$} to \DataSty{j$_z$}. The properties of our adapted \texttt{CSA} also ensure that this range maintains the same size after translation and it can also be directly translated to a range in the \DataSty{s$_z$}.
    
    \item In \textbf{line 13} we obtain the starting position of the section for the stop \DataSty{s$_z$} in the CSA with a \FuncSty{Select} operation over the bitvector D from \texttt{CSA}. This is necessary for operating on \texttt{WML} and \texttt{WMJ} to restrict the line and journeys for the final stop.
    
    \item In \textbf{line 14} the range \DataSty{a'}$..$\DataSty{z'} is trivially translated to the section for \DataSty{s$_z$} where we query \texttt{WML} to obtain the subrange for the line \DataSty{l$_z$}. Remember that \DataSty{WML}{(s$_z$)} represents only the lines for \DataSty{s$_z$}, therefore both the translated indexes and the resulting subrange indexes are relative and must be adjusted by \DataSty{offset}. This would have not been necessary if the optimization was not implemented, and absolute indexes would have been used. \ojo{Revisar muchos interrogantes}
    
    \item In \textbf{line 15} we obtain the jcode range analogously to line 8, but this time for \DataSty{l$_z$} and \DataSty{s$_z$}.
    
    \item In \textbf{line 16} we return the number of entries of \texttt{WMJ} between \DataSty{j$_a$} and \DataSty{j$_z$} within our final subrange. The function \FuncSty{GetCount} does not report any range boundaries as \FuncSty{GetRange} does, but simply returns the number of occurrences. Of course, the time complexity of this operation is still proportional to the height of the WM.
    %even though the matching entries can be scattered (not delimiting a contiguous range).
\end{itemize}

It is trivial to reuse the Algorithm~\ref{alg:xy} to answer queries with less constrains. For example, if we were only interested in restricting the starting line, we could return \DataSty{z}-\DataSty{a} after line 7. Or if we only wanted to restrict the ending line and time, we can do it by skipping the lines 4-12, and using directly \FuncSty{GetRange}{(\FuncSty{WML}{(s$_z$)},left-offset,right-offset,l$_z$)} in line 14. The complexity would increase if we restricted by a time window but not by lines, as would need to iterate through all possible lines for \DataSty{s$_a$} and \DataSty{s$_z$} to obtain the jcodes for each line and perform these operations on \texttt{WML} and \texttt{WMJ}. Fortunately, the number of lines that a single stop can belong to tends to be rather small in practice, thus with a careful implementation that avoids repeating computation the performance of such query scales well, as will be shown later in Section~\ref{sec:exp}. Finally, to obtain only the trips that started on a given stop we would simply need to set \DataSty{pattern} to $\{0,s_a\}$ in line 2, or alternatively to $\{s_z,0\}$ for the final stop, and skipping the operations on the sections of \DataSty{s$_z$} or $\$$, respectively.

Of course, \ctr~can also be used to efficiently obtain other interesting information about trips, such as the top k most boarded stops, 
%as shown in \cite{brisaboa2018compact} \ojo{NO}, 
with the possibility of differentiating stops that are only used to switch lines in \ctr. However, to the best of our knowledge, there is no known way of using this representation to obtain other kinds of information efficiently (e.g. the number of passengers in a journey between two stops).

\subsection{Analyzing \acumm, \ttctr~and \ctr}
\label{sec:comp}
To illustrate the application of each representation, as well as highlight the motivation for the development of \ctr, in this section we discuss in detail the worst case time complexities of each query described in Section~\ref{sec:rq}. 

Being $l$ the number of lines we restrict to, $|L|$ the total number of lines represented, $|S|$ the number of stops in the line L and $\bar{|J^l|}$ is the average number of jcodes per line.


\begin{threeparttable}
\centering
\caption{Worst case time complexities of the representations in Section~\ref{sec:ps}}
\label{tab:queries}
\begin{tabular}{|l|l|l|l|}
\hline
Query &  \acumm & \ttctr & \ctr\\
\hline
\texttt{board\_X$_{LT}$} & $O(l)$ & $O(l\times \log(\bar{|J^l|}))$\tnote{$\otimes$} & \ctrq\tnote{$\otimes$} \\
\texttt{alight\_X$_{LT}$} & $O(l)$ & Hard\tnote{$\ddagger$$\diamondsuit$} & Hard\tnote{$\ddagger$$\diamondsuit$} \\
\texttt{use\_L$_T$} & O(1) & $O(|S|\times \log(\bar{|J^l|}))$\tnote{$\otimes$} \hspace{0.4cm} & $O(|S| \times \ctrq)$\tnote{$\otimes$} \\
%\texttt{alight\_L$_T$} & O(1) & $O(|S|\times \log(\bar{|J^l|}))$\tnote{$\otimes$$\ddagger$} & $O(|S| \times \ctrq)$\tnote{$\otimes$$\ddagger$} \\
\texttt{board\_T} & $O(|L|)$ & Hard\tnote{$\diamondsuit$} & Hard\tnote{$\diamondsuit$} \\
\texttt{alight\_T} & $O(|L|)$ & Hard\tnote{$\ddagger$$\diamondsuit$} & Hard\tnote{$\ddagger$$\diamondsuit$} \\
\texttt{load\_X$_{LT}$} & $O(l)$ & Hard\tnote{$\ddagger$$\diamondsuit$} & Hard\tnote{$\ddagger$$\diamondsuit$} \\
\hline
\texttt{start\_X$_{LT}$} & - & \ttctrq\tnote{$\otimes$} & \ctrq\tnote{$\otimes$} \\
\texttt{end\_X$_{LT}$} & - & $O(|S|\times \ttctrq)$\tnote{$\otimes$} & \ctrq\tnote{$\otimes$} \\
\texttt{switch\_X$_{LT}$} & - & \ttctrq\tnote{$\otimes$} & \ctrq\tnote{$\otimes$} \\
\texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} & - & $O(|S|\times \ttctrq)$\tnote{$\otimes$} & \ctrq\tnote{$\otimes$} \\
\texttt{start\_L$_T$} & - & $O(|S|\times \ttctrq)$\tnote{$\otimes$}~~~ & $O(\log(|L|\times\bar{|J^l|}))$ \\
\texttt{end\_L$_T$} & - & Hard\tnote{$\diamondsuit$} & $O(|S| \times \ctrq)$\tnote{$\otimes$} \\
\texttt{start\_T} & - & Hard\tnote{$\diamondsuit$} & $O(|L| \times \log(|L|\times\bar{|J^l|}))$~~ \\
\texttt{end\_T} & - & Hard\tnote{$\diamondsuit$} & Hard\tnote{$\diamondsuit$} \\
\hline
\end{tabular}

\begin{tablenotes}
%\item[a] $l$ is the number of lines we restrict to.
\item[$\otimes$] The complexity of varies with the restrictions. See discussion.
\item[$\ddagger$] May include false positives.
\item[$\diamondsuit$] Not practical to solve with the indexing capabilities of this representation.
%\item[e] $|S|$ is the number of stops in the line L.
%\item[f] $|L|$ is the total number of lines represented.
%\item[g] $\bar{|J^l|}$ is the average number of jcodes per line.
\end{tablenotes}
\end{threeparttable}

\medskip
Before explaining the details of how each of these operations would be implemented in our representations, it is worth noting that the complexity of \ctrq~will depend on the restrictions that are applied, as they will yield different variations of Algorithm~\ref{alg:xy}, as explained by the end of the Section~\ref{sec:ctr}. Generally, the time complexity of \ctrq~with all the restrictions is bounded by one \FuncSty{GetRange} operation on \FuncSty{CSA} to restrict by a stop id, one on \FuncSty{WML} to restrict by a line id and finally another one on \FuncSty{WMJ} to restrict by jcodes, with a total complexity of $O(\log(n\times|L|\times\bar{|J^l|}))$, being $n$ the size of the represented sequences\footnote{While theoretically locating a pattern of length $m$ in a Suffix Array takes $O(m \log n)$ time, in our case $m$ is bounded to 2 or 3 (in case of \texttt{from\_X\_to\_Y}). Furthermore, with a backward search implementation, only $m-1$ binary searches are needed.}.
However, when only the time is restricted, every line that the queried stop belongs to must be considered, thus increasing the worst-case complexity to $O(\log(n) + |L|\times \log(|L|\times\bar{|J^l|}))$. Similarly, the complexity of \ttctrq~is normally a search in the \texttt{CSA} and a \FuncSty{GetRange} on the \texttt{WM} (if time is restricted), which would amount to $O(\log(n) + \log(bar{|J^l|}))$, although when only the time and not the line is restricted, we must perform a new query for every possible line, and the complexity increases to $O(|L|\times (\log(n) + \log(bar{|J^l|})))$, which is generally higher than the one from \ctrq.

\begin{itemize}
    \item \texttt{board\_X$_{LT}$} This can be solved easily in the \acumm, as there are aggregated matrices for boarding stops, even though it is necessary to access a separate matrix for every line queried, hence $O(l)$. For \ttctr, the number of occurrences for the stop X is counted by delimiting its range on \FuncSty{D} (with a constant time $select$ operation) and filtering down the \texttt{WM} if needed. For \ctr, the filtering is done through \FuncSty{WML} and \FuncSty{WMJ}, and after that we must subtract the occurrences of final stops, obtained by one \texttt{end\_X$_{LT}$} with the same restrictions.
    \item \texttt{alight\_X$_{LT}$} Both in \ttctr~and \ctr, the only alighting stops that are explicitly represented are the final stops. To obtain an approximated count of the rest of them, we would need to extract and examine all the occurrences for \texttt{board\_W$_{LT}$} for every stop W that could have been boarded before X, as the worst-case time complexity of solving with their index operations is prohibitive. On the other hand, it can be solved much faster in \acumm~by accessing the alighting matrices.
    \item \texttt{use\_L$_T$} Straightforward in \acumm, as it only needs to access one matrix. For \ttctr~we must filter through the \texttt{WM} for every stop from L. While in \ctr~the total number of occurrences of line L can be calculated in one $O(\log|L|)$ operation (with additional filtering through \FuncSty{WMJ} if needed), we need to subtract the occurrences of start\_L$_T$ and end\_L$_T$, the later having a greater complexity of $O(|S| \times \ctrq)$.
    %\item \texttt{alight\_L$_T$} Can be approximated both in \ttctr~and \ctr~with board\_L$_T$, given that every user that boards on a line is expected to alight from it within a reasonable time.
    \item \texttt{board\_T} and \texttt{alight\_T} Although \acumm, \ttctr~and \ctr~could solve it by applying use\_L$_T$ $|L|$ times, this would imply a prohibitive cost for both \ttctr~and \ctr, where extracting all the trips would be preferred in practice.
    \item \texttt{load\_X$_{LT}$} It is possible to solve this kind of query using both, alighting and boarding matrices. Knowing how many travelers got on and off the vehicle previously to one particular point makes trivial to determine how many of them are in the vehicle at each tract. This method is easily adapted to measure the average number through an interval of time.
    \item \texttt{start\_X$_{LT}$} Cannot be solved in \acumm. In the two other representations, we need to the range for the pattern $\$X$ in the \FuncSty{CSA} and filtering down \FuncSty{WML} and \FuncSty{WMJ} if needed.
    \item \texttt{end\_X$_{LT}$} In \ctr~it is solved similarly to \texttt{start\_X$_{LT}$}, by delimiting the range for the pattern $X\$$ in the \FuncSty{CSA} and filtering down \FuncSty{WML} and \FuncSty{WMJ} if needed. It can be much more complex for \ttctr, where the only way to restrict a line is to make a new query for every stop that could have been boarded before X in that line, which is a problem detailed at the start of Section~\ref{sec:ctr}.
    \item \texttt{switch\_X$_{LT}$} Calculated as board\_X$_{LT}$ - start\_X$_{LT}$.
    \item \texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} Explained in detail in Algorithm~\ref{alg:xy}. In \ttctr~the $|S|$ factor only takes effect if the line (or time) for Y must be restricted, as for \texttt{end\_X$_{LT}$}.
    \item \texttt{start\_L$_T$} Trivially solved in \ctr, by filtering down \FuncSty{WML} and \FuncSty{WMJ}, if needed, over the $\$$ section of the \FuncSty{CSA}. On the other hand, for \ttctr~the \texttt{CSA} needs to be queried with the $\$X$ pattern for every stop X from line $l$.
    \item \texttt{end\_L$_T$} Can be solved in \ctr, by performing a end\_X$_{LT}$ for every stop X from the line $l$. If we did the same for \ttctr, we would end up with a complexity of $O(|S|^2\times\ttctrq)$, which we consider prohibitive.
    \item \texttt{start\_T} Solved in the \ctr~by applying \texttt{start\_X$_{LT}$} $|L|$ times.
    \item \texttt{end\_T} None of our representations can solve this query efficiently, although it could be approximated by \texttt{start\_T} in CTR.
\end{itemize}

\section{Experiments}
\label{sec:exp}
In this section we discuss the practical performance of our structures. To evaluate them, we have run randomly generated queries against \acumm, \ttctr~and \ctr~built over a dataset of user trips over a real transportation network (Section~\ref{sec:data}), with several configurations to study the trade-off between compression (Section~\ref{sec:space}) and query efficiency (Section~\ref{sec:time}), and testing different configurations for each individual structure.

\subsection{Experimental dataset}
\label{sec:data}
Using real GTFS\footnote{\url{https://developers.google.com/transit/gtfs/}} descriptions of bus routes and schedules, we generated a synthetic dataset of user trips that aims to realistically imitate real user behaviour over a month. In this work, we have combined the GTFS obtained for the networks of urban\footnote{Provided by EMT \url{http://www.emtmadrid.es}} and interurban\footnote{Provided by CRTM \url{http://www.crtm.es}} buses for the city of Madrid. The network model was extracted and user trips were generated with the following general steps:

\begin{enumerate}
    \item We parsed stop, route and trip identifiers. This produced two lines per route in almost all cases, one for each direction. With this we were able to build the common structures $lineStop$ and $stopLine$.
    \item We connected stops that are on a short walking distance (100 meters) from each other, or appear sequentially on the same line.
    \item We parsed the schedules for bus trips.
    \item We generated a month of journeys from the schedules, differentiating days of week. From this we computed $avgTime$ and $initialTime$.
    \item User trips were generated. A trip starts from a random stop, day and journey and simulates boarding that journey and traversing it. After each traversed stop, the user may end the trip with a probability that starts at zero and increases by 1\% for every stop visited. Additionally, there is a fixed probability of attempting to switch lines at the current stop, if there is a journey available at that stop within the allowed waiting time (30 minutes) and from a different line\footnote{The reverse of the current line is also disallowed.}. Switching lines is also attempted when the end of the current line is reached.
    \item We persisted these generated trips as sequences of stages \\ $<<line,journey,boarding\_stop>, <line,journey,alighting\_stop>>$,\\ where a boarding and alighting stop naturally share the same line and journey within the same stage. This results in the same number of stages as lines have been used. With the parameters used, about 56\% of our trips have one stage, 33\% have two, 9\% have three and 2\% have four.
\end{enumerate}

With this approach we have generated a dataset of ten million trips, over a real network consisting of 11021 stops, 1048 lines for a simulated month\footnote{A period of 31 days, starting with a Monday.}, with an average of 1622 journeys per line and a maximum of 9980. We consider that this synthetic dataset is of enough accuracy and size to obtain significant results when studying the compression capabilities and performance of our representations.

\subsection{Space requirements}
\label{sec:space}
We have measured the sizes of all the individual components of our representation in memory built over the experimental dataset. We present the sizes of our common structures, followed by the \acumm. After that, we compare the compression achieved with \ttctr~and \ctr.

For the \texttt{CSA} structures from \ttctr~and \ctr, we experiment with the $t_\Psi$ (sampling interval) factors of 32, 128 and 512. For the \texttt{WM} present in \ttctr, as well as in the two \texttt{WM} from \ctr, we analyze the space required by the \texttt{RRR} bitvector described in \cite{Raman:2002:SID:545381.545411}, using block sizes of 32, 64 and 128, and compare it against a plain bitvector with a rank structure, which we call \texttt{RG32}.

The space occupied by the common structures is reflected in Table~\ref{tab:commons}. These were represented using plain fixed bit length integers with the exception of $initialTime$, where we used the compression approach discussed in Section~\ref{sec:cs} with a sampling interval of 512. This has allowed us to represent all required network information in a negligible space of less than 1 MiB.

\begin{table}
    \centering
    \caption{Sizes of the common structures}
    \label{tab:commons}
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
        Structure & $lineStop$ & $stopLine$ & $avgTime$ & $initialTime$ & Total \\
        \hline
        Size (KiB) & 119 & 141 & 64 & 440 & 764 \\
    \hline
    \end{tabular}
\end{table}

To measure the sizes occupied by the different variants of \acumm~that were presented in Section~\ref{sec:acumm}, we have summed the total space required by each line matrix. These results, which can be found in Table~\ref{tab:acuum}, helped us prove that \texttt{Blocks} is an effective strategy to reduce the size of the accumulated values. While \texttt{Diff} is also able to reduce the total space, it's fundamentally constrained by the shape of our matrices, making it less desirable in this context.

\begin{table}
    \centering
    \caption{Sizes of the different variants from \acumm}
    \label{tab:acuum}
    \begin{tabular}{|c|c|c|c|}
    \hline
        Variant & \texttt{Sum} & \texttt{Diff} & \texttt{Blocks} \\
        \hline
        Size (MiB) & 55.49 & 43.81 & 28.68 \\
    \hline
    \end{tabular}
\end{table}

In Table~\ref{tab:ttctr} we analyze the space occupied by the two structures of \ttctr: a \texttt{CSA} that encodes stops and their lines, and a \texttt{WM} that encodes journey codes.

\begin{table}
    \caption{Space requirements for the \texttt{CSA} (a) and the \texttt{WM} (b) from \ttctr}
    \label{tab:ttctr}
    \begin{subtable}[t]{.30\linewidth}
    \vspace{-12pt}
    \caption{\footnotesize (a)}
    \vspace{-12pt}
    \begin{tabular}[t]{|l|l|r|}
        \hline
        t$_\Psi$ & bps & Size (MiB) \\
         \hline
        32 & 7.288 & 30.91 \\
        128 & 6.069 & 25.74 \\
        512 & 5.761 & 24.43 \\
        \hline
    \end{tabular}
    \end{subtable}%
    \begin{subtable}[t]{.40\linewidth}
    \vspace{-12pt}
    \caption{\footnotesize (b)}
    \vspace{-12pt}
    \begin{tabular}[t]{|l|l|r|}
        \hline
        Bitvector & bps & Size (MiB) \\
         \hline
        RG32 & 14.438 & 44.02 \\
        RRR32 & 13.478 & 41.09 \\
        RRR64 & 12.79 & 38.99 \\
        RRR128 & 12.446 & 37.94 \\
        \hline
    \end{tabular}
    \end{subtable}
\end{table}

We have observed that when we use a very sparse of $t_\Psi$, the \texttt{CSA} is able to achieve remarkably small representations, as it captures the repetitiveness of trips when constrained to our network of bus lines.

We were not able to achieve such compression for the \texttt{WM}, where compressing the bitvectors with \texttt{RRR} results in a \texttt{WM} that is only slightly smaller than the baseline with the plain bitvector. This sequence is indeed hard to compress, given than it was rearranged to be aligned to the entries of our \texttt{CSA}, which nullifies any local redundancy that other kinds of arrangements may obtain.

We also measured the occupied space of \ctr~in Table~\ref{tab:ctr}, where three structures must be taken in consideration: a \texttt{CSA} that only encodes stop identifiers, and two \texttt{WM}: one for line identifiers (\texttt{WML}) and one for journey codes (\texttt{WMJ}).

\begin{table}
    \caption{Space requirements for the \texttt{CSA} (a), the \texttt{WMJ} (b) and the \texttt{WML} (c) from \ctr}
    \label{tab:ctr}
    \begin{subtable}[t]{.28\linewidth}
    \vspace{-12pt}
    \caption{\footnotesize (a)}
    \vspace{-12pt}
    \begin{tabular}[t]{|l|l|r|}
        \hline
        t$_\Psi$ & bps & Size (MiB) \\
         \hline
        32 & 6.956 & 29.50 \\
        128 & 5.727 & 24.29 \\
        512 & 5.417 & 22.97 \\
        \hline
    \end{tabular}
    \end{subtable}
    \begin{subtable}[t]{.38\linewidth}
    \vspace{-12pt}
    \caption{\footnotesize (b)}
    \vspace{-12pt}
    \begin{tabular}[t]{|l|l|r|}
        \hline
        Bitvector & bps & Size (MiB) \\
         \hline
        RG32 & 14.438 & 61.23 \\
        RRR32 & 13.419 & 56.91 \\
        RRR64 & 12.732 & 53.99 \\
        RRR128 & 12.388 & 52.53 \\
        \hline
    \end{tabular}
    \end{subtable}
    \begin{subtable}[t]{.30\linewidth}
    \vspace{-12pt}
    \caption{\footnotesize (c)}
    \vspace{-12pt}
    \begin{tabular}[t]{|l|l|r|}
        \hline
        Bitvector & bps & Size (MiB) \\
         \hline
        RG32 & 4.778 & 20.26 \\
        RG32 & 2.338 & 9.91 \\
        RG64 & 2.18 & 9.24 \\
        RG128 & 2.103 & 8.92 \\
        \hline
    \end{tabular}
    \end{subtable}%
\end{table}

When comparing to the structures of \ttctr, we can observe that \texttt{WMJ} of \ctr, despite achieving a marginally better compression than the \texttt{WM} from \ttctr, requires considerably more space, as the sequence of jcodes from \ctr~includes final stops, while in \ttctr~they are skipped.

Contrary to the case of \texttt{WMJ} or the \texttt{WM} from \ttctr, we are able to achieve significant compression with \texttt{WML}. When using the baseline bitvector \texttt{RG32}, we are already obtaining a very compact representation, due to the optimization discussed in Section~\ref{sec:ctr}, where we keep a separate \texttt{WM} aligned to each stop from the \texttt{CSA}, resulting in much shorter \texttt{WM}s. The further compression achieved with the \texttt{RRR} bitvectors is possible because the stop entries in the \texttt{CSA} are sorted by either the final stop the user alights to or the next stop to board, making the aligned sequence of lines very predictable. Additionally, as our \texttt{CSA} maintains the order of trips from the original text in the $\$$ section, leading to the formation of clusters in the first \texttt{WML}.

In Table~\ref{tab:comp}~we also evaluate the compression of the overall \ttctr~and \ctr~representations with respect to a plain representation of the user trips that we use as input, which are the triplets $<s,l,j>$ seen in Section~\ref{sec:ttctr}, where the stop identifiers, line identifiers and journey codes had to be represented with 14, 11 and 14 bit integers, respectively. We only show the compression ratios for the four configurations that will be tested in the following Section~\ref{sec:time}, combining two $t_{\Psi}$ and two \texttt{WM} configurations\footnote{In case of \ctr, this refers to bitvectors from both \texttt{WML} and \texttt{WMJ}.}. A more realistic baseline would be a relational database representation, where additional fixed-width integers would be needed to maintain foreign key relations, thus requiring much more space than our chosen baseline.

\begin{table}
    \centering
    \caption{Compression of \ttctr~and \ctr~when compared to a plain representation of the user trips with fixed-width integeres}
    \label{tab:comp}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \cline{3-8}
    \multicolumn{2}{c}{} & \multicolumn{2}{|c|}{plain} & \multicolumn{2}{|c|}{\ttctr} & \multicolumn{2}{|c|}{\ctr} \\
    \hline
    $t_{\Psi}$ & \texttt{WM} & Size & Comp. (\%) & Size & Comp. (\%) & Size & Comp. (\%) \\
    \hline
    32 & RG32 & \multirow{4}{*}{165.39} & \multirow{4}{*}{100} & 81.73 & 49.42 & 111.73 & 67.56 \\
    32 & RRR128 & & & 75.66 & 45.75 & 91.70 & 55.44 \\
    512 & RG32 & & & 75.25 & 45.50 & 105.21 & 63.61 \\
    512 & RRR128 & & & 69.18 & 41.83 & 85.17 & 51.50 \\
    \hline
    \end{tabular}
\end{table}

It is clear to see that when compared to the same baseline, the compression ratios of \ctr~are inferior to the ones of \ttctr, for any configuration tested. This result is not surprising considering that \ctr~separates the line identifiers into a separate \texttt{WM}, that is proven less compressible than a \texttt{CSA} for repetitive sequences, although we have also observed that although the \texttt{CSA} is slightly smaller in \ctr, the compression ratios are worse than the ones in \ttctr~when we compare to a smaller baseline that only represents the sequence of stops, with no information about lines. In the next section we will demonstrate the advantages of this separation of line identifiers in query performance.

\subsection{Query performance}
\label{sec:time}
We have implemented the most adequate queries for \ttctr~and \ctr~from those described in Section~\ref{sec:rq}, and measured their average execution time from 100.000 randomly generated queries on a Intel Xeon E5-2620v4@2.1 GHz machine. In this section we will only discuss four of the possible configurations tested for both \ttctr~and \ctr, with t$_{\Psi}$ values of 32 and 512 combining with \texttt{WM} using either uncompressed bitvectors (\texttt{RG32}) or the most compressed (\texttt{RRR128}). These four configurations should be illustrative enough to provide an understanding of the space-time trade-offs of our approaches, although the execution times for all tested configurations can be found in the Appendix A.

We demonstrate the main advantage of \ctr~over the older \ttctr~ in the Figure~\ref{fig:start}b, where restricting a line or a time interval for an \texttt{end\_X} query is very expensive for \ttctr~ due to its separate vocabulary for final stops, requiring to query the \texttt{CSA} for every possible stop that could have been boarded before X to restrict a line. In the Figure~\ref{fig:start}a it is also possible to see how the performance of \ctr~degrades less with a highly compressed \texttt{CSA} for the query \texttt{start\_X$_T$}, where even queries over a compressed \texttt{WML} are faster than queries over the \texttt{CSA}.

\marginpar{Consider changing the order of the bars}

\begin{figure}[hbt!]
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/start.eps}
\vspace{-12pt}
\caption{\footnotesize (a)}
\vspace{-12pt}
\end{subfigure}%
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/end.eps}
\vspace{-12pt}
\caption{\footnotesize (b)}
\vspace{-12pt}
\end{subfigure}
\caption{Comparison of \texttt{start\_X$_{LT}$} (a) and \texttt{end\_X$_{LT}$} (b) queries, with all variants. Note the logarithmic scale for the y axis in (b)}
\label{fig:start}
\end{figure}

Remember that restricting both the line and time is always cheaper than only restricting the time, as for the later more operations need to be performed to filter every line. This explains why $T$ queries are always slower than $LT$ queries. This is true for both representations, with any configuration and query.

We can see more examples of this difference in performance between these two representations with the \texttt{from\_X\_to\_Y} queries in the Figure~\ref{fig:xy0}, whenever the end lines or times are restricted. Additionally, we can yet again observe how using the most sparse sampling of $\Psi$ affects much more the \ttctr~than the \ctr, with the performance of \texttt{from\_X$_{T}$\_to\_Y} consistent with the \texttt{start\_X$_T$} shown in Figure~\ref{fig:start}a.

\begin{figure}[hbt!]
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/xy0.eps}
\vspace{-12pt}
\caption{\footnotesize (a)}
\vspace{-12pt}
\end{subfigure}%
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/xy1.eps}
\vspace{-12pt}
\caption{\footnotesize (b)}
\vspace{-12pt}
\end{subfigure}
\caption{Comparison of \texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} queries, variating line (a) and starting time (b) restrictions}
\label{fig:xy0}
\end{figure}

The performance of both representations can sometimes improve  when more selective restrictions are added, where the execution is cut short when no matching trips are found, before evaluating further restrictions. For this reason, the average times for \texttt{from\_X$_{T}$\_to\_Y$_{L}$} and \texttt{from\_X$_{LT}$\_to\_Y$_{L}$} are shorter than those of \texttt{from\_X\_to\_Y$_{L}$} and \texttt{from\_X$_{L}$\_to\_Y$_{L}$}.

When restricting to the end time, \ctr~consistently outperforms \ttctr, as shown in the Figure~\ref{fig:xy2}. which is to be expected considering the large number of times that the \texttt{CSA} from \ttctr~needs to be queried, yielding results similar to those from the Figure~\ref{fig:start}b where the end time is also restricted.

\begin{figure}[hbt!]
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/xy2.eps}
\vspace{-12pt}
\caption{\footnotesize (a)}
\vspace{-12pt}
\end{subfigure}%
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/xy3.eps}
\vspace{-12pt}
\caption{\footnotesize (b)}
\vspace{-12pt}
\end{subfigure}
\caption{Comparison of \texttt{from\_X$_{LT}$\_to\_Y$_{LT}$} queries, variating line (a) and starting time (b) restrictions with a fixed ending time restriction}
\label{fig:xy2}
\end{figure}

The high selectivity of time restrictions explain why \ttctr~appears to become more competitive with the most restrictive queries of Figure~\ref{fig:xy2}b. However, its query time still increases several times when the \texttt{CSA} is highly compressed.

The only query for which \ttctr~is clearly preferred over \ctr~is \texttt{board\_X}, with any restriction, as can be seen in the Figure~\ref{fig:board}a. Both for \texttt{board\_X} and \texttt{board\_X$_{L}$}, \ttctr~takes on average less than one microsecond per query, as the only operations needed are two constant time $select$ over the bitvector \texttt{D} from the \texttt{CSA}, while \ctr~needs to subtract the occurrences of $X\$$ (as those are alighting stops, not boarding), for which $\Psi$ must be accessed. This advantage is carried on the queries with time restrictions as well.

\begin{figure}[hbt!]
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/board.eps}
\vspace{-12pt}
\caption{\footnotesize (a)}
\vspace{-12pt}
\end{subfigure}%
\begin{subfigure}{0.5\linewidth}
\includegraphics[width=\linewidth]{experiments/board_t.eps}
\vspace{-12pt}
\caption{\footnotesize (b)}
\vspace{-12pt}
\end{subfigure}
\caption{Comparison of \texttt{board\_X$_{LT}$} queries, with all variants (a) and also with all variants of \acumm~(b). Note the logarithmic scale in (b), as well as the measurements in nanoseconds}
\label{fig:board}
\end{figure}

When comparing the best performing configuration of \ttctr~to the different variants of \acumm~discussed in Section~\ref{sec:acumm}, we can observe wildly different results in Figure~\ref{fig:board}b depending on the variant of the \texttt{board\_X} query used. The biggest difference is observed when comparing queries that filter by time, which use the \textt{WM} in \ttctr, while for any variant of \acumm~solves it in a small number of constant time operations. Another evident difference occurs within each \acumm~variant, where the queries that are restricted to a single line are significantly faster than those that consider every line, as the later must query a different matrix for every line that the stop appears in. It was also expected to see the compressed variants \texttt{Diff} and \texttt{Blocks} perform slower than the uncompressed \texttt{Sum}, as the two former store relative values that must be resolved, increasing the number of memory accesses, although still by a constant factor. This also hints for a reason why the queries \texttt{board\_X} and \texttt{board\_X$_{L}$} seem to be slightly faster in \ttctr~than any of the \acumm, as a higher number of accesses over larger memory regions in \acumm~makes cache misses more frequent. Nevertheless, the difference is very small, within the same microsecond.

Obviously, \acumm~may be used to solve a grater number of queries in much faster time than either \ttctr~or \ctr. We did not find it interesting to report the run times for those queries as they are mostly equal to those shown in Figure~\ref{fig:board}b, due to being resolved with the same CPU operations. Refer to the complexities Table~\ref{tab:queries} to obtain an accurate estimate of the time that it would take for \acumm~to solve each of the supported queries.


\section{Conclusions}
\label{sec:conc}
In this work we have presented in detail our two compact representations for public transportation user trajectories: \ttctr~and \ctr, that follow a conceptual model that aims to eliminate redundancy while being adaptable to most transportation network schemes around the world. We have also determined there is a need for a third representation that we call \acumm, to accelerate some types of queries that would be otherwise impractical for the former representations, due to their time complexity.

In the future, we aim to find a single representation that is powerful enough to support all our proposed kinds of queries. Finding such a representation is a considerable challenge as many of the known aggregation techniques make it impossible to maintain an elegant relation to the original representation. In our case, means that we would not be able to find and reconstruct the original trajectories of the users without additional heavy structures, that would negate the usefulness of a compact representation.

In order to allow an end user to put in practice the concepts that were developed here, it is also necessary to extend this work to build a usable GIS interface. The high spatial and temporal efficiency of our representations would make it possible to maintain all our indexed dataset in memory and perform bulk operations (such as calculating the number of trips originated at one of the stops from a region) responsively.

Finally, I can't think of anything pretty to wrap this up. I'm tired of this article.

\bibliographystyle{splncs04}
\bibliography{refs}

\input{appendix.tex}

\end{document}
